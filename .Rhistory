demo()
demo(Hershey)
a <- available.packages()
head(rownames(a),10)
install.packages("slidify")
install.packages("ggplot2")
install.packages("devtools")
library(slidify)
search()
install.packages("slidify")
update.packages(checkBuilt=TRUE, ask=FALSE)
library(devtools)
find_rtools()
install("KernSmooth")
install.packages("KernSmooth")
library(KernSmooth)
install.packages("slidify")
mySpecialMatrix <- makeCacheMatrix(matrix(c(1:4),2,2))
source('~/.active-rstudio-document')
mySpecialMatrix <- makeCacheMatrix(matrix(c(1:4),2,2))
mySpecialMatrix
cacheSolve(A)
cacheSolve(mySpecialMatrix)
source('~/S/DataScience/RProgramming/ProgrammingAssignment2/cachematrix.R')
A <- makeCacheMatrix(matrix(c(1:4),2,2))
cacheSolve(A)
cacheSolve(A)
A$set(matrix(c(2:5),2,2))
cacheSolve(A)
cacheSolve(A) %*% A
cacheSolve(A) %*% A$get()
B <- cacheSolve(A)
A$get() %*% B
# ezer
Now
1+2
set.seed(1)
rpois(5, 2)
?rnorm
rnorm(10000)
head(rnorm(1000000))
?set.seed
?ppois
?rbinom
rbinom(10, 10, 0.5)
x <- rbinom(10, 10, 0.5)
set.seed(10)
x <- rbinom(10, 10, 0.5)
e <- rnorm(10, 0, 20)
y <- 0.5 + 2 * x + e
plot(x,y)
makeCacheMatrix <- function(x = matrix()) {
inverse <- NULL
set <- function(y) {
x <<- y
inverse <- NULL
}
get <- function() x
setinverse <- function(inv) inverse <<- inv
getinverse <- function() inverse
list(set=set, get=get,
getinverse = getinverse,
setinverse = setinverse)
}
## INPUT: output of makeCacheMatrix
## OUTPUT: inverse of matrix
## in the inverse matrix has been calculated, get the inverse matrix and skips computation.
## otherwise, calculates the inverse matrix and sets the inverse matrix in the cache via setinverse function.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inverse <- x$getinverse()
if(!is.null(inverse)) {
message("getting cached data")
return(inverse)
}
data <- x$get()
inverse <- solve(data)
x$setinverse(inverse)
inverse
}
makeCacheMatrix(A)
A
A$get
A <- makeCacheMatrix
A
A <- makeCacheMatrix(matrix(c(1:4),2,2))
cacheSolve(A)
cacheSolve(A)
cacheSolve(A) %*% A$get()
A$set(matrix(c(2:5),2,2))
cacheSolve(A)
B <- makeCacheMatrix(matrix(c(3:6),2,2))
cacheSolve(B)
makeCacheMatrix <- function(x = matrix()) {
inverse <- NULL
set <- function(y) {
x <<- y
inverse <<- NULL
}
get <- function() x
setinverse <- function(inv) inverse <<- inv
getinverse <- function() inverse
list(set=set, get=get,
getinverse = getinverse,
setinverse = setinverse)
}
## INPUT: output of makeCacheMatrix
## OUTPUT: inverse of matrix
## in the inverse matrix has been calculated, get the inverse matrix and skips computation.
## otherwise, calculates the inverse matrix and sets the inverse matrix in the cache via setinverse function.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inverse <- x$getinverse()
if(!is.null(inverse)) {
message("getting cached data")
return(inverse)
}
data <- x$get()
inverse <- solve(data)
x$setinverse(inverse)
inverse
}
A <- makeCacheMatrix(matrix(c(1:4),2,2))
C <- makeCacheMatrix(matrix(c(1:4),2,2))
cacheSolve(C)
C$set(matrix(c(2:5),2,2))
cacheSolve(C)
makeCacheMatrix <- function(x = matrix()) {
inverse <- NULL
set <- function(y) {
x <<- y
inverse <- NULL
}
get <- function() x
setinverse <- function(inv) inverse <<- inv
getinverse <- function() inverse
list(set=set, get=get,
getinverse = getinverse,
setinverse = setinverse)
}
## INPUT: output of makeCacheMatrix
## OUTPUT: inverse of matrix
## in the inverse matrix has been calculated, get the inverse matrix and skips computation.
## otherwise, calculates the inverse matrix and sets the inverse matrix in the cache via setinverse function.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inverse <- x$getinverse()
if(!is.null(inverse)) {
message("getting cached data")
return(inverse)
}
data <- x$get()
inverse <- solve(data)
x$setinverse(inverse)
inverse
}
D <- makeCacheMatrix(matrix(c(1:4),2,2))
cacheSolve(D)
D$set(matrix(c(2:5),2,2))
cacheSolve(D)
c("1","3")
?perm
?comb
?permutation
?rperm
clear
clear()
cls()
?rbern
setwd("~/S/DataScience/ExploratoryDataAnalysis/ExData_Plotting1")
?unzip
source('~/S/DataScience/ExploratoryDataAnalysis/ExData_Plotting1/plot1.R')
source('~/S/DataScience/ExploratoryDataAnalysis/ExData_Plotting1/plot1.R')
?fread
source('~/S/DataScience/ExploratoryDataAnalysis/ExData_Plotting1/plot1.R')
source('~/S/DataScience/ExploratoryDataAnalysis/ExData_Plotting1/plot1.R')
head(DT)
DT <- fread(dataFile, na.strings="?", select=c("Date","Time","Global_active_power")
)
DT[1,3]
type(2)
datatype(3)
str(3)
str(DT[1,3])
str(DT)
DT[3,1]
DT[3,]
DT[3,2]
DT[3,][3]
DT[3,]
str(DT[3,])
summary(DT)
DT[6840,]
